---
output: word_document
---
#### R Notes
* Objects
    + 5 basic types of objects: character, numeric, integer, complex, logical
    +	Vectors can only contain objects of the same class
    + Lists can contain objects of different classses, but are represented as vectors
    + Empty vectors can be created with the vector() function
*	Numbers
    +	Numbers in R are generally treated as numeric objects
    +	Special number inf which represents infinity
    +	The value NaN represents an undefined value or a missing value
*	Attributes
    +	R objects can have names, dimnames, class, dimensions, length, etc
    +	Attributes can be accessed using the attributes() function
* Vectors
    + The c() and vector() function can be used to create vectors of objects
    + When different objects are mixed in a vector, coercion occus so that every element in the vector is of the same class
    + Explicit coercion can occur using the as.*() functions, ie as.numeric()
    + Nonsensical coercion results in NAs
    + Lists are s special type of vector that can contain elements of different classes
```{r}
a <- c(0.5, 0.6) ##numeric
b <- c(TRUE, FALSE) ##logical
c <- c(T, F) ##logical
d <- c("a", "b", "c") ##character
e <- 1:35 ##integer
f <- c(1+0i, 2+4i) ##complex
g <- vector ("numeric", length = 10)
h <- c(1.7, "a") ##character
i <- c(TRUE, 2) ##numeric
j <- c("a", TRUE) ##character
a
b
c
d
e
f
g
h
i
j
k <- 2:8
class(k)
as.numeric(k)
as.logical(k)
as.character(k)
l <- c("a", "b", "c")
as.numeric(l)
as.logical(l)
as.complex(l)
m <- list(1, "a", TRUE, 1+4i)
m
```
* Matrices
    + Vectors with a dimension attribute [an integer vector of length 2 (nrow, ncol)] 
    + Matrices are constructed column-wise starting with the upper left corner and running down the columns
    + Matrices can also be created from vectors by adding a dimension attribute or by column-binding or row-binding with cbind(), rbind()
```{r}
a <- matrix(nrow = 2, ncol = 3)
a
dim(a)
attributes(a)
b <- matrix(1:6, nrow = 2, ncol = 3)
b
c <- 1:10
c
dim(c) <- c(2,5)
c
d <- 1:3
e <- 10:12
cbind(d, e)
rbind(d, e)
```
* Factors
    + These are used to represent categorical data and can be ordered or unordered
    + Using factors with labels are better than using integers because factors are self-describing i.e. Male/Female rather than 1/2
    + Factors are treated specially by modelling functions like lm() and glm()
    + The order to the levels can be set using the levels argument, this is important since the first level is used as the baseline level
```{r}
a <- factor(c("yes", "yes", "no", "yes", "no"))
a
table(a)
unclass(a)
a <- factor(c("yes", "yes", "no", "yes", "no"), level = c("yes", "no"))
a
```
* Missing Values
    + These are denoted by NA or NaN and are tested by is.na() or is.nan()
    + NA values have the normal classes (integer, character, etc)
    + is.na or is.nan are used to test if objects are NA or NaN
    + A NaN value is also NA, but the converse is also true
```{r}
a <- c(1, 2, NA, 10, 3)
is.na(a)
is.nan(a)
b <- c(1, 2, NaN, NA, 4)
is.na(b)
is.nan(b)
```
* Data Frames
    + Used to store tabular data and are represented as a special of list where every element has to have the same length
    + Each element of the list can be thought of as a column and the length of the list the number of rows
    + Unlike matrices, data frames can store different classes of objects in each column
    + Have special attribute row.names
    + Created by calling read.table() or read.csv()
    + Can be converted to a matrix by calling data.matrix()
```{r}
a <- data.frame(foo = 1:4, bar = c(T, T, F, F))
a
nrow(a)
ncol(a)
```
* Names
    + Are useful for writing readable code and self-describing objects 
    + Lists and matrices can also have names
```{r}
a <- 1:3
names(a)
names(a) <- c("foo", "bar", "norf")
a
names(a)
b <- list(a = 1, b = 2, c = 3)
b
c <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(c) <- list(c("a", "b"), c("c", "d"))
c
```
* Reading Tabular Data
    + read.table(), read.csv() are for reading text files (inverse of write.table())
    + readLines() is for reading lines of a text file (inverse of writeLine())
    + source() and dget() are for reading in R code files (inverse of dump() and dput())
    + load() is for reading in saved workspaces (inverse of save())
    + unserialize() is of reading single R objects in binary form (inverse of serialize())
    + read.table() Arguments
        + file, name of the file or a connection
        + header, logical indicating if the file has a header line
        + sep, a string indicating how the columns are separated
        + colClasses, a character vector indicating the class of each column in the dataset
        + nrows, the number of rows in the dataset
        + comment.char, a character string indicating the comment character
        + skip, the number of lines to skip from the beginning
        + stringsAsFactors, should character variables be coded as factors
    + When using read.table R will automatically, skip lines that begin with a #, figure out how many rows there are and what type of variable is in each column
* Reading Large Tables
    + 
    + 
```{r}

```
*   
    +
```{r}

```
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
